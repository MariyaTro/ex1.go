package main

import "fmt"

func main() {
	var x, y, z uint8

	x = 9
	y = 28
	z = x

	fmt.Println("Бітові операції")

	fmt.Printf("^x      = ^(%d)      = ^(%.8b)            = %.8b = %d\n", x, x, ^x, ^x)
	fmt.Printf("x << 2  = (%d << 2)  = (%.8b << 2)        = %.8b = %d\n", x, x, x<<2, x<<2)
	fmt.Printf("x >> 2  = (%d >> 2)  = (%.8b >> 2)        = %.8b = %d\n", x, x, x>>2, x>>2)
	fmt.Printf("x & y   = (%d & %d)  = (%.8b & %.8b)  = %.8b = %d\n", x, y, x, y, x&y, x&y)
	fmt.Printf("x | y   = (%d | %d)  = (%.8b | %.8b)  = %.8b = %d\n", x, y, x, y, x|y, x|y)
	fmt.Printf("x ^ y   = (%d ^ %d)  = (%.8b ^ %.8b)  = %.8b = %d\n", x, y, x, y, x^y, x^y)
	fmt.Printf("x &^ y  = (%d &^ %d) = (%.8b &^ %.8b) = %.8b = %d\n", x, y, x, y, x&^y, x&^y)
	fmt.Printf("x %% y   = (%d %% %d)  = (%.8b %% %.8b)  = %.8b = %d\n", x, y, x, y, x%y, x%y)

	fmt.Println("\nБітові операції з присвоюванням")

	x = z
	x &= y
	fmt.Printf("x &= y   = (%d &= %d)  = (%.8b &= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x |= y
	fmt.Printf("x |= y   = (%d |= %d)  = (%.8b |= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x ^= y
	fmt.Printf("x ^= y   = (%d ^= %d)  = (%.8b ^= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x &^= y
	fmt.Printf("x &^= y  = (%d &^= %d) = (%.8b &^= %.8b) = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x %= y
	fmt.Printf("x %%= y   = (%d %%= %d)  = (%.8b %%= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)

	// Завдання.
	// 1. Пояснити результати операцій

	// Виконання

	/*
					Операції з бітами:
							1. ^x (Інвертує всі біти числа):
							Оператор ^ інвертує біти числа. Наприклад, x = 9 (в бінарному вигляді 00001001) дає результат -10 (в двійковому доповненні).

						    2. x << 2 (Зсув вліво на 2 біти):
							Зсув на 2 біти вліво множить число на 4. Для x = 9, результат 36.

							3. x >> 2 (Зсув вправо на 2 біти):
							Зсув вправо ділить число на 4. Для x = 9, результат 2.

							4. x & y (Бітове І):
							Результат встановлюється в 1, якщо обидва біти рівні 1. Для x = 9 і y = 28, результат 8.

							5. x | y (Бітове АБО):
							Результат встановлюється в 1, якщо хоча б один з бітів 1. Для x = 9 і y = 28, результат 29.

							6. x ^ y (Бітове виключне АБО):
							Результат встановлюється в 1, якщо біти різні. Для x = 9 і y = 28, результат 21.

							7. x &^ y (Бітове АБО з запереченням):
							Встановлює 1 в тих бітах, де в x є 1, а в y — 0. Для x = 9 і y = 28, результат 1.

							8. x % y (Взяття залишку від ділення):
							Оператор % дає залишок від ділення. Для x = 9 і y = 28, результат 9.

					Операції з присвоюванням:
			                1. x &= y (Бітове І з присвоюванням):
		                	Еквівалентно x = x & y. Тобто, кожен біт x обчислюється як результат бітового І між відповідними біти x і y. Результат після операції &= буде 8.
		                	Виведено: x &= y = (9 &= 28) = (00001001 &= 00011100) = 00001000 = 8

		                	2.x |= y (Бітове АБО з присвоюванням):
		                	Еквівалентно x = x | y. Результат після операції |= буде 29.
		                	Виведено: x |= y = (9 |= 28) = (00001001 |= 00011100) = 00011101 = 29

		                	3.x ^= y (Бітове виключне АБО з присвоюванням):
		                	Еквівалентно x = x ^ y. Результат після операції ^= буде 21.
		                	Виведено: x ^= y = (9 ^= 28) = (00001001 ^= 00011100) = 00010101 = 21

		                	4.x &^= y (Бітове АБО з запереченням з присвоюванням):
		                	Еквівалентно x = x &^ y. Результат після операції &^= буде 1.
		                	Виведено: x &^= y = (9 &^= 28) = (00001001 &^= 00011100) = 00000001 = 1

		                	5.x %= y (Операція взяття залишку з присвоюванням):
		                	Еквівалентно x = x % y. Результат після операції x %= y буде 9.
		                	Виведено: x %= y = (9 %= 28) = (00001001 %= 00011100) = 00001001 = 9
	*/
}
